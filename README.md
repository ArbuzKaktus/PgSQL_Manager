# Employee Management System (SQL Manager)

Приложение для управления справочником сотрудников с использованием PostgreSQL.

## Описание

Консольное приложение на C++ для работы с базой данных сотрудников. Поддерживает создание таблиц, добавление записей, массовый импорт данных и оптимизацию запросов.

### Архитектура

Проект реализован с применением современных паттернов проектирования:

- **Command Pattern** - каждый режим работы реализован как отдельная команда
- **Factory Pattern** - создание команд на основе входных параметров
- **Strategy Pattern** - различные стратегии генерации данных (Random/Targeted)
- **SOLID принципы** - четкое разделение ответственности между классами

### Основные классы

- `Application` - точка входа, управление приложением
- `Employee` - представление сотрудника с методом расчета возраста
- `DatabaseManager` - работа с PostgreSQL (подключение, запросы, оптимизация)
- `ICommand` - интерфейс команд (режимы 1-6)
- `CommandFactory` - фабрика для создания команд
- `IDataGenerator` - интерфейс стратегий генерации данных

## Требования

- C++17 или выше
- CMake 3.10+
- PostgreSQL 12+
- libpqxx (C++ connector for PostgreSQL)
- g++ или clang++

## Установка зависимостей

### Ubuntu/Debian

```bash
sudo apt update
sudo apt install build-essential cmake postgresql postgresql-contrib libpq-dev libpqxx-dev
```

### Arch Linux

```bash
sudo pacman -S base-devel cmake postgresql libpqxx
```

### macOS (с Homebrew)

```bash
brew install cmake postgresql libpqxx
```

## Настройка базы данных

1. Запустите PostgreSQL:

```bash
sudo systemctl start postgresql
```

2. Создайте базу данных:

```bash
sudo -u postgres psql
CREATE DATABASE employees_db;
CREATE USER postgres WITH PASSWORD 'postgres';
GRANT ALL PRIVILEGES ON DATABASE employees_db TO postgres;
\q
```

3. Настройте подключение:

```bash
# Скопируйте пример конфигурации
cp include/config.h.example include/config.h

# Отредактируйте include/config.h и укажите ваши настройки:
# - DB_HOST (по умолчанию: localhost)
# - DB_PORT (по умолчанию: 5432)
# - DB_NAME (по умолчанию: employees_db)
# - DB_USER (по умолчанию: postgres)
# - DB_PASSWORD (по умолчанию: postgres)
```

## Сборка проекта

```bash
mkdir build
cd build
cmake -G Ninja ..
ninja
```

Или с использованием Make:

```bash
mkdir build
cd build
cmake ..
make
```

После успешной сборки будет создан исполняемый файл `SqlManager`.

## Использование

### Режим 1: Создание таблицы

Создает таблицу `employees` с полями: ФИО, дата рождения, пол.

```bash
./SqlManager 1
```

### Режим 2: Добавление сотрудника

Добавляет одного сотрудника в базу данных.

```bash
./SqlManager 2 "Ivanov Petr Sergeevich" 2009-07-12 Male
```

Параметры:
- Полное имя (в кавычках)
- Дата рождения (формат: YYYY-MM-DD)
- Пол (Male или Female)

### Режим 3: Вывод всех сотрудников

Выводит все уникальные записи (по ФИО + дата рождения), отсортированные по ФИО.

```bash
./SqlManager 3
```

Вывод включает: ФИО, дату рождения, пол и возраст (полных лет).

### Режим 4: Массовое заполнение данными

Автоматически создает 1,000,100 записей:
- 1,000,000 записей с равномерным распределением по полу и начальной букве
- 100 записей мужчин с фамилией, начинающейся на "F"

```bash
./SqlManager 4
```

**Внимание**: Эта операция может занять несколько минут!

### Режим 5: Поиск сотрудников с замером времени

Выполняет поиск мужчин с фамилией, начинающейся на "F", и замеряет время выполнения.

```bash
./SqlManager 5
```

Вывод включает:
- Количество найденных записей
- Время выполнения запроса (в миллисекундах)
- Все найденные результаты (полный вывод)

**Пример вывода:**
```
Query completed in 324 ms
Found 189442 employees matching criteria
Displaying all 189442 results:
[... полный вывод всех записей ...]
```

### Режим 6: Оптимизация базы данных

Применяет 4 техники оптимизации и сравнивает время выполнения до и после.

```bash
./SqlManager 6
```

**Применяемые техники:**
1. **Partial Index** - частичный индекс только для Male с фамилией 'F'
2. **Covering Index** - покрывающий индекс со всеми нужными колонками
3. **VACUUM ANALYZE** - освобождение места и обновление статистики
4. **Увеличение work_mem** - 256MB для ускорения сортировки

**Пример вывода:**
```
Time BEFORE optimization: 441 ms
Time AFTER optimization:  324 ms
Performance improvement: 26.53%
Time saved: 117 ms
```

## Описание классов

### Employee

Класс для представления сотрудника.

**Поля:**
- `fullName` - Полное имя (Фамилия Имя Отчество)
- `birthDate` - Дата рождения (YYYY-MM-DD)
- `gender` - Пол (Male/Female)

**Методы:**
- `calculateAge()` - Вычисляет возраст в полных годах
- `saveToDB()` - Сохраняет сотрудника в БД
- `batchSaveToDB()` - Статический метод для пакетной вставки

### DatabaseManager

Класс для работы с PostgreSQL.

**Методы:**
- `connect()` / `disconnect()` - Управление соединением
- `createTable()` - Создание таблицы
- `insertEmployee()` - Вставка одной записи
- `batchInsertEmployees()` - Пакетная вставка массива сотрудников
- `getAllEmployees()` - Получение всех уникальных записей
- `getEmployeesByCriteria()` - Поиск по критериям (пол, префикс фамилии)
- `createOptimizationIndex()` - Применение 4 техник оптимизации
- `dropIndex()` - Удаление индексов оптимизации
- `clearCache()` - Очистка кэша для точных замеров
- `explainQuery()` - Вывод плана выполнения запроса

## Оптимизация (Режим 6)

### Применяемые техники

Режим 6 последовательно применяет 4 техники оптимизации PostgreSQL:

#### 1. Partial Index (Частичный индекс)

Создается индекс только для нужных записей:

```sql
CREATE INDEX idx_employees_male_f_surname 
ON employees (full_name, birth_date)
WHERE gender = 'Male' AND full_name >= 'F' AND full_name < 'G';
```

**Преимущества:**
- Индексирует только целевые записи (~19% таблицы)
- Значительно меньше по размеру, чем полный индекс
- Быстрее обновляется при INSERT/UPDATE

#### 2. Covering Index (Покрывающий индекс)

Индекс содержит все колонки запроса:

```sql
CREATE INDEX idx_employees_covering 
ON employees (gender, full_name, birth_date)
WHERE gender = 'Male';
```

**Преимущества:**
- PostgreSQL может выполнить Index-Only Scan
- Не требуется обращение к основной таблице
- Ускоряет сортировку и выборку данных

#### 3. VACUUM ANALYZE

Очистка и обновление статистики таблицы:

```sql
VACUUM ANALYZE employees;
```

**Что делает:**
- Освобождает место от удаленных записей
- Обновляет статистику для планировщика запросов
- Улучшает планы выполнения запросов

#### 4. Увеличение work_mem

Выделение больше памяти для операций сортировки:

```sql
SET work_mem = '256MB';
```

**Эффект:**
- Сортировка выполняется в памяти, а не на диске
- Ускоряет операции DISTINCT и ORDER BY
- Снижает нагрузку на дисковую подсистему

### Результаты оптимизации

После применения всех техник достигается значительное ускорение:

| Метрика | Без оптимизации | С оптимизацией | Улучшение |
|---------|-----------------|----------------|-----------|
| Время выполнения | 459-705 мс | 313-324 мс | **31-54%** |
| Найдено записей | 189,442 | 189,442 | без изменений |
| Техники | нет | 4 техники | - |

**Примечание:** Для очень больших выборок (>15-20% таблицы) PostgreSQL может предпочесть 
параллельный последовательный просмотр (Parallel Seq Scan) индексному сканированию, 
так как это эффективнее благодаря параллельной обработке.

## Структура базы данных

```sql
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    full_name VARCHAR(255) NOT NULL,
    birth_date DATE NOT NULL,
    gender VARCHAR(10) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## Примеры использования

### Полный цикл работы:

```bash
# 1. Создать таблицу
./SqlManager 1

# 2. Добавить тестовую запись
./SqlManager 2 "Smith John Michael" 1990-05-15 Male

# 3. Посмотреть содержимое
./SqlManager 3

# 4. Заполнить большим объемом данных
./SqlManager 4

# 5. Проверить скорость запроса (без оптимизации)
./SqlManager 5

# 6. Оптимизировать и сравнить
./SqlManager 6
```

### Применённые техники оптимизации

1. **Partial Index** - индексирует только целевые записи
2. **Covering Index** - избегает обращений к основной таблице  
3. **VACUUM ANALYZE** - обновляет статистику планировщика
4. **Увеличение work_mem** - ускоряет сортировку в памяти

Подробнее см. [REPORT.md](REPORT.md)
